# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-dcy0c0IHPkQ4rgnlaCoFfgMG74Bzuic
"""

#!pip install streamlit

import streamlit as st
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from io import BytesIO
import pickle
from sklearn.preprocessing import StandardScaler

# Load pretrained model (placeholder for future implementation)
@st.cache_resource
def load_model():
    with open('model.pkl', 'rb') as file:
        model = pickle.load(file)
    return model

# model = load_model()  # Commented out for now, as we are using hardcoded output

# Load Dataset
@st.cache_data
def load_data():
    file_path = "./data/dataset_without_outliers2.csv"
    df = pd.read_csv(file_path)
    return df

# Load dataset
df = load_data()

# App Title
st.title("Aig端es de Barcelona - AquaMetrics: Prioritization & Monitoring Dashboard")

# Navigation Sidebar
st.sidebar.image("images/ab_logo.png", use_container_width=True)
st.sidebar.title("Navigation")
page = st.sidebar.radio("Go to:", [
    "Home",
    "Prediction Page",
    "Prioritization Ranking Table",
    "Analytics Tools"
])

# Home Page
if page == "Home":
    # Title and Header
    #st.header("Aig端es de Barcelona - AquaMetrics: Prioritization & Monitoring Dashboard")

    # Introduction to the App
    st.subheader("Overview")
    st.markdown('''
    Welcome to the Aig端es de Barcelona AquaMetrics: Prioritization & Monitoring Dashboard. This platform is designed to assist in the efficient prioritization of water meter upgrades based on key operational metrics, providing a data-driven approach to enhancing water management in Barcelona.
    ''')

    # Key Features Section
    st.subheader("Key Features")
    st.markdown('''
    - **Prioritization & Ranking**: Rank water meters based on factors such as consumption levels, usage type, and meter characteristics.
    - **Data Visualization**: Gain insights through interactive charts and visualizations.
    - **Filtering & Analysis**: Filter meters by usage type, consumption, and diameter for targeted analysis.
    - **Data Export**: Easily export ranked data for reporting and further analysis.
    ''')

    # Upgrade Recommendations Section
    st.subheader("Suggested Upgrade Recommendations")
    st.markdown('''
    - **Upgrade All Mechanical Meters in Industrial Zones**: Mechanical meters in high-usage industrial areas are a key focus for upgrades.
    - **Prioritize Meters with High Monthly Waste in Commercial Areas**: Identifying high-waste meters in commercial zones can lead to better efficiency and resource allocation.
    ''')

    # Footer Note
    st.markdown("---")
    st.markdown('''
    #### How to Use This App
    Use the navigation bar on the left to explore different aspects of the water meter prioritization:
    - **Prediction Page**: Enter meter details to get a recommendation on whether to upgrade to an electric meter.
    - **Prioritization Ranking Table**: View and filter a ranked list of water meters.
    - **Analytics Tools**: Explore various visualizations and analyses to understand water meter data in depth.
    ''')

# Prediction Page
elif page == "Prediction Page":
    # Page title
    #st.title("Aig端es de Barcelona - Model Prediction Page")

    # Short explanation for the page
    st.markdown("""
    ### Model Prediction

    This page allows you to input key metrics about a water meter to get a prediction for whether it should be upgraded to an **electric** or kept as **mechanical**.
    Please fill in the fields below and click the **Run Prediction** button to see the recommendation.
    """)

    # Input fields for prediction
    st.markdown("#### Please fill in the information below:")

    # Dropdown for Use
    use_options = ["AJUNTAMENT", "INDUSTRIAL", "COMERCIAL", "DOMESTIC"]
    selected_use = st.selectbox("Select Usage Type:", options=use_options)

    # Dropdown for HousingType
    housing_type_options = ["A", "B", "C", "D", "W", "U"]
    selected_housing_type = st.selectbox("Select Housing Type:", options=housing_type_options)

    # Input for Diameter
    diameter = st.number_input("Diameter of the Meter (cm):", min_value=0.0, step=0.1)

    # Input for Monthly Waste
    monthly_waste = st.number_input("Monthly Waste (Liters):", min_value=0.0, step=0.1)

    # Run button
    if st.button("Run Prediction"):
        # For showcasing purposes, output a hardcoded answer
        st.success("Prediction: **Electric Meter (E)**")

    # Suggestions for improvement
    st.markdown("""
    ### Suggestions for Future Enhancement

    - **Confidence Score:** Show a confidence score of the prediction to provide more transparency on the model's decision.
    - **Detailed Report:** Provide more context on why the model made the specific prediction (e.g., feature importance values).
    - **Batch Prediction:** Add functionality to run multiple predictions simultaneously using a CSV file upload.
    """)

# Prioritization Ranking Table Page
elif page == "Prioritization Ranking Table":
    #st.header("Ranking Table")
    st.markdown("### Ranked Water Meters")
    st.markdown('''
    This page shows a sample table of water meters ranked based on a made-up priority score.
    The current version demonstrates a prioritization ranking using randomly sampled data.
    ''')

    # Sample Data from Dataset
    sampled_df = df.sample(20).reset_index(drop=True)
    sampled_df["Priority Score"] = np.random.rand(len(sampled_df))  # Fake priority score for demonstration
    sampled_df["Priority Rank"] = sampled_df["Priority Score"].rank(ascending=False).astype(int)

    # Display the Sample Table
    st.markdown("### Sample Ranked Table:")
    st.dataframe(sampled_df[["Technology", "Use", "Diameter", "MonthlyWaste", "Priority Score", "Priority Rank"]])

    # Export Top 10
    top_10 = sampled_df.sort_values(by="Priority Rank").head(10)
    buffer = BytesIO()
    with pd.ExcelWriter(buffer, engine="xlsxwriter") as writer:
        top_10.to_excel(writer, index=False, sheet_name="Top 10")

    st.download_button(
        label="Download Top 10 as Excel",
        data=buffer,
        file_name="top_10_ranked.xlsx",
        mime="application/vnd.ms-excel"
    )

# Consolidated Analytics Tools Page
elif page == "Analytics Tools":
    #st.header("Analytics Tools")
    st.markdown("""
    ### Analytics Tools

    This page provides various visualizations and analysis tools to explore the dataset in detail. It includes options for:
    - Viewing key metrics and trends
    - Interactively filtering and analyzing specific features
    - Gaining insights into relationships between different variables
    """)

    # Overview Section
    st.markdown("### Overview of Dataset Metrics")
    total_meters = len(df)
    average_monthly_waste = round(df["MonthlyWaste"].mean(), 2)
    st.markdown(f"#### Total Number of Meters: {total_meters}")
    st.markdown(f"#### Average Monthly Waste: {average_monthly_waste} Liters")

    # General Visual
    # Bar Chart: Average Monthly Waste by Use
    st.markdown("### Average Monthly Waste by Use")
    avg_waste_by_use = df.groupby("Use")["MonthlyWaste"].mean().reset_index()
    fig1, ax1 = plt.subplots()
    sns.barplot(data=avg_waste_by_use, x="Use", y="MonthlyWaste", ax=ax1)
    st.pyplot(fig1)

    # Download Button for Bar Chart
    buf1 = BytesIO()
    fig1.savefig(buf1, format="png")
    buf1.seek(0)
    st.download_button(
        label="Download Bar Chart as PNG",
        data=buf1,
        file_name="average_monthly_waste_by_use.png",
        mime="image/png",
    )

    # Histogram: Diameter Distribution
    st.markdown("### Diameter Distribution")
    fig2, ax2 = plt.subplots()
    sns.histplot(df["Diameter"], bins=20, kde=True, ax=ax2)
    st.pyplot(fig2)

    # Download Button for Histogram
    buf2 = BytesIO()
    fig2.savefig(buf2, format="png")
    buf2.seek(0)
    st.download_button(
        label="Download Histogram as PNG",
        data=buf2,
        file_name="diameter_distribution.png",
        mime="image/png",
    )

    # Heatmap: Correlations
    st.markdown("### Correlation Heatmap")
    corr = df[["Diameter", "MonthlyWaste"]].corr()
    fig3, ax3 = plt.subplots()
    sns.heatmap(corr, annot=True, cmap="coolwarm", ax=ax3)
    st.pyplot(fig3)

    # Download Button for Heatmap
    buf3 = BytesIO()
    fig3.savefig(buf3, format="png")
    buf3.seek(0)
    st.download_button(
        label="Download Heatmap as PNG",
        data=buf3,
        file_name="correlation_heatmap.png",
        mime="image/png",
    )

    # Scatter Plot: Diameter vs. MonthlyWaste
    st.markdown("### Scatter Plot: Diameter vs. MonthlyWaste")
    fig4, ax4 = plt.subplots()
    sns.scatterplot(data=df, x="Diameter", y="MonthlyWaste", hue="Use", ax=ax4)
    st.pyplot(fig4)

    # Download Button for Scatter Plot
    buf4 = BytesIO()
    fig4.savefig(buf4, format="png")
    buf4.seek(0)
    st.download_button(
        label="Download Scatter Plot as PNG",
        data=buf4,
        file_name="scatter_plot_diameter_vs_monthly_waste.png",
        mime="image/png",
    )

# Footer
st.sidebar.markdown("---")
st.sidebar.markdown("### About")
st.sidebar.markdown("This app is a prototype for prioritizing water meter upgrades.")